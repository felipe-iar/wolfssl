#include "hal_data.h"
#ifdef HAVE_CONFIG_H
    #include <config.h>
#endif

#include <wolfssl/wolfcrypt/settings.h>
#include <wolfcrypt/benchmark/benchmark.h>

typedef struct func_args {
    int    argc;
    char** argv;
    int    return_code;
} func_args;

static unsigned long long Stack[256*4*16] @ ".noinit";

func_args args = { 0 } ;

extern double current_time(int reset);
double current_time(int reset) 
{
    static timer_status_t status;
    
    if (reset)
    {
        g_timer0.p_api->reset(&g_timer0_ctrl);
    }
    
    g_timer0.p_api->statusGet(&g_timer0_ctrl, &status);
    
    return (double)(status.counter / 60000000U) ;
}

uint32_t g_timer_overflow_flg = 0;
void g_timer0_callback(timer_callback_args_t * p_args)
{
  if (NULL != p_args) 
  {
    g_timer_overflow_flg = 1;
  }
}
  
/* QnD patch: to provide __iar_data_init3() */
__root int __dummy(void) { __iar_data_init3(); return 1; }

FSP_CPP_HEADER
void R_BSP_WarmStart(bsp_warm_start_event_t event);
FSP_CPP_FOOTER

/*******************************************************************************************************************//**
 * main() is generated by the RA Configuration editor and is used to generate threads if an RTOS is used.  This function
 * is called by main() when no RTOS is used.
 **********************************************************************************************************************/
void hal_entry(void)
{
    fsp_err_t err = FSP_SUCCESS;
    
    err = g_timer0.p_api->open(&g_timer0_ctrl, &g_timer0_cfg);
    if (FSP_SUCCESS != err)
    {
        while (1);
    }
    
    err = g_timer0.p_api->start(&g_timer0_ctrl);
    if (FSP_SUCCESS != err)
    {
        while (1);
    }
  
    benchmark_test(&args);

#if BSP_TZ_SECURE_BUILD
    /* Enter non-secure code */
    R_BSP_NonSecureEnter();
#endif
}

/*******************************************************************************************************************//**
 * This function is called at various points during the startup process.  This implementation uses the event that is
 * called right before main() to set up the pins.
 *
 * @param[in]  event    Where at in the start up process the code is currently at
 **********************************************************************************************************************/
void R_BSP_WarmStart (bsp_warm_start_event_t event)
{
    if (BSP_WARM_START_RESET == event)
    {
#if BSP_FEATURE_FLASH_LP_VERSION != 0

        /* Enable reading from data flash. */
        R_FACI_LP->DFLCTL = 1U;

        /* Would normally have to wait tDSTOP(6us) for data flash recovery. Placing the enable here, before clock and
         * C runtime initialization, should negate the need for a delay since the initialization will typically take more than 6us. */
#endif
    }

    if (BSP_WARM_START_POST_C == event)
    {
        /* C runtime environment and system clocks are setup. */

        /* Configure pins. */
        R_IOPORT_Open(&g_ioport_ctrl, &g_bsp_pin_cfg);
    }
}

#if BSP_TZ_SECURE_BUILD

BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable ();

/* Trustzone Secure Projects require at least one nonsecure callable function in order to build (Remove this if it is not required to build). */
BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable ()
{

}
#endif
